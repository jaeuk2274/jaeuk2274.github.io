---
title: "프로그래머스-해시-베스트앨범"
date: 2020-01-23
categories: 
- Algorithm
tags:
- Programmers
comments : true
---


~~~java
package me.jaeuk;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;

/**
 * https://programmers.co.kr/learn/courses/30/lessons/42578?language=java
 * 프로그래머스-해시-베스트앨범
 *
 */
public class 베스트앨범 {
    public static void main(String[] args) {

        String[] genres = {"classic", "pop", "classic", "classic", "pop", "test", "test", "test"};
        int[] plays = {500, 600, 150, 800, 2500, 5000, 5000, 4999};

        베스트앨범 베스트앨범 = new 베스트앨범();
        int[] answer = 베스트앨범.solution(genres, plays);

        for (int i:answer) {
            System.out.print(i + " ");
        }
    }

    /*
    * 문제풀이 고민
    * 1. 해시에 넣어서 장르별로 재생횟수 합 구하기 + vo 안에 넣기 list
    * 2. 해시 정렬해서 재생횟수 높은 순 정렬 (문제에서 모든 장르는 재생 횟수가 다르다고 명시해줌)
    * 3. vo 정렬 (장르 + 재생횟수)
    * 4. 장르별 2개씩만 수록한다. (2개씩 아닌것들은 remove)
     */
    public int[] solution(String[] genres, int[] plays) {
        HashMap<String, Integer> genersPlaysMap = new HashMap<String, Integer>();
        List<Music> musicList = new ArrayList<Music>();

        for(int i=0; i<genres.length; i++){
            genersPlaysMap.put(genres[i], genersPlaysMap.getOrDefault(genres[i], 0) + plays[i]);
            musicList.add(new Music(genres[i], plays[i], i));
        }

        // 요건대로 정렬(장르+재생횟수)
        musicList = sortListByGenrePlay(musicList, genersPlaysMap);

        // 각 장르별 2개씩만 남게끔 remove
        String tempGenre = musicList.get(0).getGenre();
        String curGenre = "";
        int tempGenreCnt = 0;
        for(int i=0; i<musicList.size(); i++){
            curGenre = musicList.get(i).getGenre();

            if(tempGenre.equals(curGenre)){
                tempGenreCnt++;
            }else{
                tempGenre = curGenre;
                tempGenreCnt = 1;
            }

            if(tempGenreCnt > 2){
                musicList.remove(i);
                i--;
                continue;
            }
        }

        int[] answer = new int[musicList.size()];

        int index = 0;
        for (Music m: musicList) {
            answer[index] = musicList.get(index).getSeq();
            index++;
        }

        return answer;
    }

    public static List<Music> sortListByGenrePlay(List<Music> list, HashMap<String, Integer> map){

        Collections.sort(list, new Comparator<Music>() {
            // 정렬 공부하며 새롭게 알게된 사실
            // 1. o1이 더 뒤에 나오는 객체, o2가 더 앞의 객체.
            //   (1,0)비교 -> (2,1)비교 -> (2,0)비교 -> (3,0)비교 -> (3,1)..
            // 2. o1 기준으로 -1이 더 앞으로 가는 것. (o1원래 뒤에있던 애니까 -1) ,1은 기존 들어있던 순서 그대로
            @Override
            public int compare(Music o1, Music o2) {
                // System.out.println("o1 : " + o1);
                // System.out.println("o2 : " + o2);

                // 1.장르 비교
                if(map.get(o2.getGenre()) > map.get(o1.getGenre())){
                    return 1;
                } else if(map.get(o2.getGenre()) < map.get(o1.getGenre())){
                    return -1;
                }

                // 2. 장르 같을때 재생횟수 비교 (같은 장르 내 재생횟수가 같다면? 문제에는 명시되지 않음)
                if(o2.getPlay() > o1.getPlay()){
                    return 1;
                } else if(o2.getPlay() < o1.getPlay()) {
                    return -1;
                }

                // 여기서는 예외 케이스(재생횟수 같을 때) 원래 배열에 들어있던/고유번호 순서대로 처리
                return 1;
            }
        });

        return list;
    }

    public class Music{
        private String genre;
        private int play;
        private int seq;

        public Music(String genre, int play, int seq) {
            this.genre = genre;
            this.play = play;
            this.seq = seq;
        }

        public String getGenre() {
            return genre;
        }

        public int getPlay() {
            return play;
        }

        public int getSeq() {
            return seq;
        }

        @Override
        public String toString() {
            return "Music{" +
                    "genre='" + genre + '\'' +
                    ", play=" + play +
                    ", seq=" + seq +
                    '}';
        }
    }
}
~~~

확실히 레벨이 있는 문제라 그런지 좀 더 어렵긴 했다.        
해시 문제인데 해시보다는 정렬을 활용해 푼 것 같아서.. 풀었으니 다른사람의 풀이들을 좀 참고해 보아야 겠다.      
어떻게 더 해시를 활용했는지.. 내가 잘 모르는게 있는 것 같다..    



+
- 스트림으로 멋지게 짜여진 소스가 있더라.. 하지만 성능은 8~9배정도 느리긴 한데..
- 스트림으로 이런 것까지 할 수 있다. 를 공부하는데는 괜찮은 듯
- JPA 사용하면 스트림을 많이 사용하는데, 쿼리딴 보다 Java 스트림 활용해서 처리하는게 성능상 더 이점이 많을까? 궁금증이 생겼다.
- 아니면 그정도의 차이까지는 아니라서. 상관이 없는 건가.. 싶기도 하고.



- 내가 짠 것
테스트 1 〉	통과 (2.26ms, 51.8MB)
테스트 2 〉	통과 (2.15ms, 52.2MB)
테스트 3 〉	통과 (2.41ms, 51.9MB)
테스트 4 〉	통과 (1.87ms, 52.7MB)
테스트 5 〉	통과 (2.91ms, 53MB)
테스트 6 〉	통과 (2.75ms, 52.6MB)
테스트 7 〉	통과 (2.58ms, 52.4MB)
테스트 8 〉	통과 (2.66ms, 52MB)
테스트 9 〉	통과 (2.18ms, 52.5MB)
테스트 10 〉통과 (2.98ms, 50.7MB)
테스트 11 〉통과 (1.91ms, 50.5MB)
테스트 12 〉통과 (2.36ms, 52.6MB)
테스트 13 〉통과 (2.61ms, 50.5MB)
테스트 14 〉통과 (5.98ms, 50.7MB)
테스트 15 〉통과 (2.01ms, 52.2MB)

- 스트림 활용해서  것
테스트 1 〉통과 (18.11ms, 51.1MB)
테스트 2 〉통과 (19.22ms, 53.2MB)
테스트 3 〉통과 (18.98ms, 52.8MB)
테스트 4 〉통과 (21.69ms, 52.9MB)
테스트 5 〉통과 (21.22ms, 51.4MB)
테스트 6 〉통과 (15.40ms, 53.6MB)
테스트 7 〉통과 (14.49ms, 50.9MB)
테스트 8 〉통과 (15.75ms, 51.3MB)
테스트 9 〉통과 (15.95ms, 53.5MB)
테스트 10 〉통과 (15.08ms, 51MB)
테스트 11 〉통과 (15.03ms, 52.7MB)
테스트 12 〉통과 (16.58ms, 53.1MB)
테스트 13 〉통과 (17.76ms, 51.3MB)
테스트 14 〉통과 (15.07ms, 53.3MB)
테스트 15 〉통과 (17.25ms, 53.5MB)


~~~java
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class Solution {
  public class Music implements Comparable<Music>{

    private int played;
    private int id;
    private String genre;

    public Music(String genre, int played, int id) {
      this.genre = genre; 
      this.played = played;
      this.id = id;
    }

    @Override
    public int compareTo(Music other) {
      if(this.played == other.played) return this.id - other.id;
      return other.played - this.played;
    }

    public String getGenre() {return genre;}
  }

  public int[] solution(String[] genres, int[] plays) {
    return IntStream.range(0, genres.length)
    .mapToObj(i -> new Music(genres[i], plays[i], i))
    .collect(Collectors.groupingBy(Music::getGenre))
    .entrySet().stream()
    .sorted((a, b) -> sum(b.getValue()) - sum(a.getValue()))
    .flatMap(x->x.getValue().stream().sorted().limit(2))
    .mapToInt(x->x.id).toArray();
  }

  private int sum(List<Music> value) {
    int answer = 0;
    for (Music music : value) {
      answer+=music.played;
    }
    return answer;
  }
}
~~~

Music 에서 Comparable 상속받아 compareTo 구현한 걸 보고 아 저렇게도 쓸 수 있는구나 했는데..         
(찍어봤는데)해당 코드에선 사용되고 있지 않더라..       
그래서 좀 찾아보았다.     
- 참고
- https://www.geeksforgeeks.org/comparable-vs-comparator-in-java/

sort할 때 오버라이딩 된 메소드를 참조해서 sort 하게 된다.           
눈으로 보지 않으면 궁금증이 생겨서.. 직접 해 보았다. 

~~~java
package me.jaeuk.test;

import java.util.*;

// A class 'Movie' that implements Comparable
class Movie implements Comparable<Movie>
{
    private double rating;
    private String name;
    private int year;

    // Used to sort movies by year
    public int compareTo(Movie m)
    {
        System.out.println("m : " + m);
        System.out.println("this : " + this);
        return this.year - m.year;
    }

    // Constructor
    public Movie(String nm, double rt, int yr)
    {
        this.name = nm;
        this.rating = rt;
        this.year = yr;
    }

    // Getter methods for accessing private data
    public double getRating() { return rating; }
    public String getName()   {  return name; }
    public int getYear()      {  return year;  }

    @Override
    public String toString() {
        return "Movie{" +
                "rating=" + rating +
                ", name='" + name + '\'' +
                ", year=" + year +
                '}';
    }
}

// Driver class
class Main
{
    public static void main(String[] args)
    {
        ArrayList<Movie> list = new ArrayList<Movie>();
        list.add(new Movie("Force Awakens", 8.3, 2015));
        list.add(new Movie("Star Wars", 8.7, 1977));
        list.add(new Movie("Empire Strikes Back", 8.8, 1980));
        list.add(new Movie("Return of the Jedi", 8.4, 1983));

        System.out.println("sort start");
        Collections.sort(list);
        System.out.println("sort end");

        System.out.println("sort 후");
        for (Movie movie: list)
        {
            System.out.println(movie);
        }
    }
}
~~~





