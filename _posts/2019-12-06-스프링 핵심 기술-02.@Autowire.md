---
title: 스프링 핵심 기술-02.@Autowire
date: 2019-12-06
categories:
- Spring
tags:
- Spring 
- IoC
- Bean LifeCycle
- BeanPostProcessor
- AutowiredAnnotationBeanPostProcessor
comments : true
---

https://github.com/isme2n/isme2n.github.io

## IoC 컨테이너 3부 : @Autowire 
이번 장도 마찬가지로 이전 포스트와 겹치는 내용들이 많았지만,             
중간중간 에러 사례를 보여주며 자세한 옵션들 등 도움이 되는 추가 정보들이 있었던 것 같다.     
자세한 설명은 이전 포스트를 참고하면 될 것 같다.                     

### @Autowired?        
필요한 의존 객체의 “타입"에 해당하는 빈을 찾아 주입한다.                      
-required: 기본값은 true (따라서 못 찾으면 애플리케이션 구동 실패)                    

-사용할 수 있는 위치           
>1.생성자 (스프링 4.3 부터는 생략 가능)         
2.세터           
3.필드          


### 빈 주입 경우의 수 
1.해당 타입의 빈이 없는 경우    
2.해당 타입의 빈이 한 개인 경우       
3.해당 타입의 빈이 여러 개인 경우         


하나씩 살펴보자면      
1.
생성자, 혹은 setter로 의존성 주입 시에 만약 북 레포지터리가 등록되지 않은 빈이라면?
 
생성자 방식
{% highlight java linenos %}
@Service
public class BookService {

    BookRepository bookRepository;

    @Autowired
    public BookService(BookRepository bookRepository) {
      this.bookRepository = bookRepository;
    }
}
{% endhighlight %}

{% highlight xml linenos %}
Description:
Parameter 0 of method setBookRepository in me.whiteeship.springapplicationcontext.BookService required a bean of type 'me.whiteeship.springapplicationcontext.BookRepository' that could not be found.

Action:
Consider defining a bean of type 'me.whiteeship.springapplicationcontext.BookRepository' in your configuration.
{% endhighlight %}
    
Description:       
이 생성자의 0번째 파라미터에 설정한 북서비스에 필요한 BookRepository 빈이 없다          
Action:        
따라서 레포지터리 타입을 빈으로 정의해라.            


setter 방식
{% highlight java linenos %}
@Service
public class BookService {

    BookRepository bookRepository;

    @Autowired
    public void setBookRepository(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
    }
}
{% endhighlight %}

역시 같은 오류가 발생한다.
{% highlight xml linenos %}
***************************
APPLICATION FAILED TO START
***************************

Description:
Parameter 0 of method setBookRepository in me.whiteeship.springapplicationcontext.BookService required a bean of type 'me.whiteeship.springapplicationcontext.BookRepository' that could not be found.
{% endhighlight %}


여기서 알 수 있는게 한 가지 더 있는데,            
이 케이스를 보면                   
생성자 주입은 빈(BookService)을 만들다가 빈에 필요한 다른 의존성이었던 빈(BookRepository)이 없어서 실패했구나..         
라고 명확히 보이고 추정을 할 수 있습니다.        

그런데 setter 방식의 경우에 클래스를 다시 한번 보면,        
setBookRepository를 호출을 한 것도 아닌데, BookService 자체의 인스턴스는 생성을 할 수 있지 않나? 라는 생각을 할 수 있습니다.       
이 말은 맞는 말인데, 적어도 BookService 자체는 만들 수 있는데        
@Autowired 해당 어노테이션을 사용했기 때문에, 해당 빈(BookService)을 만들때부터 의존성을 주입을 시도합니다.        
즉, 그 과정이 실패하기 때문에 에러가 발생하는 것입니다.         


그렇다면 이걸 해결할 수 있는 방법이 있는데,       
난 의존성 무조건 필요하지는 않다. 라는 설정을 통해 정상적으로 실행할 수 있습니다.

{% highlight java linenos %}
@Service
public class BookService {

    BookRepository bookRepository;

    @Autowired(required = false) // 의존성 주입이 꼭 필요한건 아니다, default 는 true
    public void setBookRepository(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
    }
}
{% endhighlight %}

@Autowired(required = false) 해당 설정을 활용할 수 있습니다.                
(디폴트는 true)          
>true의 경우 의존성이 없거나 해당하는 빈의 타입을 못찾거나, 의존성 주입을 할 수 없는 경우에는 에러 및 구동 불가



2.
해당 타입의 빈이 한 개인 경우 문제 없이 실행이 될 거고

3.

만약 의존성을 주입하는 의존성 타입이 두개가 있을 경우는?   

#### 같은 타입의 빈이 여러개 일 때        
3-1.@Primary        
3-2.해당 타입의 빈 모두 주입 받기        
3-3.@Qualifier 
         
북 리퍼지토리 타입이 2개일 경우      

{% highlight java linenos %}
public interface BookRepository {
}

@Repository
public class JaeukRepository implements BookRepository {
}

@Repository
public class MyBookRepository implements BookRepository{
}
{% endhighlight %}

BookRepository 를 인터페이스로 바꾸고
BookRepository 타입인 JaeukRepository와 MyBookRepository 를 만든 경우


{% highlight xml linenos %}
***************************
APPLICATION FAILED TO START
***************************

Description:
Parameter 0 of method setBookRepository in me.whiteeship.springapplicationcontext.BookService required a single bean, but 2 were found:
	- jaeukRepository: defined in file [/Users/jaeuk/IdeaProjects/springapplicationcontext/target/classes/me/whiteeship/springapplicationcontext/JaeukRepository.class]
	- myBookRepository: defined in file [/Users/jaeuk/IdeaProjects/springapplicationcontext/target/classes/me/whiteeship/springapplicationcontext/MyBookRepository.class]


Action:
Consider marking one of the beans as @Primary, updating the consumer to accept multiple beans, or using @Qualifier to identify the bean that should be consumed
{% endhighlight %}

이렇게 된다면 스프링은 해당하는 타입(BookRepository)의 둘 중에서 어떤걸 원하는지 알 수 없기 때문에 주입을 해줄 수 없습니다.             


에러메세지 참조         
BookRepository 타입이 두 개가 발견되었다.            
 - JaeukRepository       
 - MyBookRepository        
둘중에 어떤걸 써야할지 모르겠다.   
    
추천 액션은    
1.@Primary 붙여서 너가 더 사용하고 싶은 것을 마킹해라.   
 
2.모든 빈을 다 주입받아라.    
 
3.@Qualifier으로 너가 뭘 원하는지 마킹을 해라     
 
1.@Primary           
{% highlight java linenos %}
@Repository @Primary
  public class JaeukRepository implements BookRepository {
}
{% endhighlight %}

여러 개의 빈을 주입해야 할 경우 난 JaeukRepository을 자주 사용할 거라고 마킹.      

2. 여러 개의 빈을 다 받아라          
@Service        
public class BookService {

    List<BookRepository> bookRepositories;

    @Autowired
    public void setBookRepository(List<BookRepository> bookRepositories) {
        this.bookRepositories = bookRepositories;
    }
}

 
3.@Qualifier           
{% highlight java linenos %}  
@Service
public class BookService {

    BookRepository bookRepository;

    @Autowired @Qualifier(value = "jaeukRepository")
    public void setBookRepository(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
    }
}
{% endhighlight %}
     
근데 @Qualifier 보다는 @Primary이 Type-Safe하니 @Primary을 더 추천.            



또 @Autowired는       
빈을 관리할때 기본적으로 타입도 보지만, 이름도 같이 봅니다.      
즉 같은 타입이라면 빈 이름으로 시도, 같은 이름의 빈 찾으면 해당 빈 사용. 같은 이름 못 찾으면 실패하는 구조입니다.                          

따라서 별로 추천하는 방법은 아니지만 이런 방식으로도 구현이 가능합니다.             
{% highlight java linenos %}  
@Service
public class BookService {

    BookRepository bookRepository;

    @Autowired
    public void setBookRepository(BookRepository jaeukRepository) {
        this.bookRepository = jaeukRepository;
    }
}
{% endhighlight %}

jaeukRepository 이름으로 판별해서 넣어줍니다.
가능은 하지만 추천하지 않고, @Primary을 더 추천합니다.       


+ 참고사항
>@Controller, @Repository 등      
각 어노테이션은 이름에 맞게 맞춰 사용하는게 좋다.      
나중에 AOP나 공통된 기능을 적용할 수도 있고, 새로운 기능을 추가하거나 aspectJ 사용하기에 좋다.     


### 동작 원리
-빈 라이프사이클(Bean LifeCycle)
-BeanPostProcessor
 >새로 만든 빈 인스턴스를 수정할 수 있는 라이프 사이클 인터페이스
-AutowiredAnnotationBeanPostProcessor extends BeanPostProcessor
 >스프링이 제공하는 @Autowired와 @Value 애노테이션 그리고 JSR-330의 @Inject 애노테이션을 지원하는 애노테이션 처리기.


동작 원리는
BeanPostProcessor의 구현체
[BeanFactory 공식문서](https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html)


빈의 초기화 라이프사이클     
1~10은 공식문서 참조.    
__11.postProcessBeforeInitialization methods of BeanPostProcessors__
__12.InitializingBean's afterPropertiesSet__
__13.a custom init-method definition__
__14.postProcessAfterInitialization methods of BeanPostProcessors__


11. 빈의 인스턴스를 만든다음(Initialization)
12. 빈의 afterPropertiesSet 초기화






있는데 그 이전 이후에 부가적인 작업을 하는 또다른 라이프사키을 콜백

이니셜라이즈

어노테이션 기반1.
@PostConstruct

2.
혹은 이니셜라이징 빈 인터페이스 메서드 구현

빈 인스턴스가 만드어진 다음 부가적인 작업을 하는 것
11. 번 주변으로피ㅏㅏㅗㅅ

![BeanPostProcesser](https://github.com/jaeuk2274/jaeuk2274.github.io/blob/master/_posts/img/%EC%8A%A4%ED%94%84%EB%A7%81%20%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20%ED%95%B5%EC%8B%AC%20%EA%B8%B0%EC%88%A0/02.BeanPostProcesser.png?raw=true)

BeanPostProcesser
빈포스트프로세서

오토와이어드 어노테이션빈프로세서가 동작
이 오토와이어드라는 어놑

빈팩토리 공식문서
https://docs.spring.io/spring-framework/docs/5.0.8.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html

AutowiredAnnotationBeanPostProcessor
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html

캡처
11/14번


@Service
public class BookService {

    BookRepository bookRepository;

    @Autowired
    public void setBookRepository(BookRepository jaeukRepository) {
        this.bookRepository = jaeukRepository;
    }

    @PostConstruct
    public void setUp() {
        System.out.println(bookRepository.getClass());
    }
}


class me.whiteeship.springapplicationcontext.JaeukRepository


2.InitializingBean 인터페이스 좀 오래된

@Service
public class BookService implements InitializingBean {

    BookRepository bookRepository;

    @Autowired
    public void setBookRepository(BookRepository jaeukRepository) {
        this.bookRepository = jaeukRepository;
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        
    }
}

추후 빈 라이프사이클 공부 및 정리! (개인적인 호기심)





11
postProcessBeforeInitialization 콜백
14
postProcessAfterInitialization 콜백
두가지 메서드를 콜백을 더제공해준다.


그중에서 AutowiredAnnotationBeanPostProcessor 얘가 이 구현체가
동작을 해서
그게 오토와이어드라는 어노테이션을 처리해준다.
해당하는 빈을 찾아서 주입을 해 준다
이니셜라이제이션 전에
11 번 postProcessBeforeInitialization

단계에서 일을 한다
 그러니까 ㅉ기히는 위치가 찌ㅏㄱ힉히는 위치가


캡처
중간이다

11번에서 동작
즉 구동을 하는 중에 동작하는 것


이거는 이 인터페이스 이 라이프사이클 콜백 경우는
1~14 중
11 단ㄱ{ㅇ[사ㅓ ㅇ;ㄹ을 하는거니까
구동 중에 찍힌다.
ㅈ

![빈 라이프사이클](https://github.com/jaeuk2274/jaeuk2274.github.io/blob/master/_posts/img/%EC%8A%A4%ED%94%84%EB%A7%81%20%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20%ED%95%B5%EC%8B%AC%20%EA%B8%B0%EC%88%A0/01.Bean%20Lifecycle.png?raw=true)


빈 포스트 프로세서라는게 있구나
이 구현체가 어떻게 동작하는가


이 정도만 
해도 
해도 충분


애플리케잇녀 컨텍스트 / 빈 팩토리가 
이 타입의 빈 / 자기 안에 등록이 되어 있는 / 빈 포스트 프로세서 BeanPostProcessor 를 찾아요
BeanPostProcessor 얘는 그 중에 하나인  AutowiredAnnotationBeanPostProcessor 얘는 이미 빈으로 등록이 되어 있는 거죠

캡처

AutowiredAnnotationBeanPostProcessor extens BeanPostProcessor
얘는 빈으로 등록이 되어 있다. 먼저 찾아서


다른 일반적인 빈들한테 
이 빈 프소트 프로세서에 있는 실제 애노테이션 처리하는 로직이 들어있는 것들을 적용하ㅡㄴ것 다른 빈들한테 적용

ㄱ기본적으로 즉 
얘도 AutowiredAnnotationBeanPostProcessor
얘도 빈으로 
얘도 빈으로 등록되어 있는 
얘도 빈으로 등록되어 있는 거죠

꺼내서 확인해보면 존재한다. 










