---
title: "스프링 데이터 JPA-19.Update 쿼리 메소드"
date: 2020-01-10
categories: 
- Back-end
tags:
- Spring 
- Spring Data
- JPA
comments : true
---

## 스프링 데이터 JPA: Update 쿼리 메소드
쿼리 생성하기
- find...
- count...
- delete...
- 흠.. update는 어떻게 하지?

Update 또는 Delete 쿼리 직접 정의하기
- @Modifying @Query
- 추천하진 않습니다.

~~~java
    @Modifying(clearAutomatically = true, flushAutomatically = true)
    @Query("UPDATE Post p SET p.title = ?2 WHERE p.id = ?1")
    int updateTitle(Long id, String title);
~~~

@Modifying 에서는
- clearAutomatically
- flushAutomatically
을 제공한다. 


강의에서도 다루지만 더 자세한 설명은 찾아서 정리해 본다.                  
참조
- https://github.com/cheese10yun/TIL/blob/master/Spring/jpa/jpa.md#%EB%B2%8C%ED%81%AC-%EC%97%B0%EC%82%B0-%EC%A3%BC%EC%9D%98%EC%A0%90


#### 벌크 연산
- 수백 개 이상의 엔티티를 하나씩 처리하기에는 시간이 너무 오래 걸린다. 이 때 여러 건을 한번에 수정하거나 삭제하는 벌크 연산을 사용 할 수 있다.
~~~java
// 재고가 10개 미만인 모든 상품의 가격을 10% 상승시키는 업데이츠
public void bulkUpdate() {
    String sql = "update Product set p.price = p.price * 1.1 where p.stockAmount < :stockAmount";

    int resultCount = em.createQuery(sql)
                        .setParameter("stockAmount", 10)
                        .executeUpdate();
}

// 100원 미만 상품을 삭제하는 코드
public void bulkDelete() {
    String sql = "delete from Product p where p.price < :price"

    int resultCount = em.createQuery(sql)
                        .setParameter("price", 100)
                        .executeUpdate();
}

// JPA 표준은 아니지만 하이버네이트는 INSERT 벌크 연산도 지원한다.
// 100원 미만의 만든 상품을 선태갷서 ProducutonTemp에 저장한다
public void bulkInsert() {
    String sql = "insert into ProductTemp(id, price, stockAmount) select p.id, p.name, p.price, p.stockAmount from Product p where p.price < :price"

    int resultCount = em.createQuery(sql)
                        .setParameter("price", 100)
                        .executeUpdate();
}
~~~
벌크 연산은 executeUpdate() 메서드를 사용한다. 이 메서드는 별크 연산으로 영향을 받은 엔티티 건수를 반환한다.

벌크 연산 주의점
- 벌크 연산을 사용할 때 벌크 연산이 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리한다는 점에 저의해애 한다.

~~~java
// 벌크 연산 시 주의점 예제
public void bulkTest() {
    // (1) 상품A의 가격은 1000 이다.
    Product product = em.createQuery("select p from Product p where p.name = :name", Product.class)
                        .setParameter("name", "productA")
                        .getSingleResult();

    // 출력 결과 : 1000
    System.out.println("Product 수정전 : " + productA.getPrice());

    // (2) 벌크 연산 수행으로 모둔 상품 가격 10% 상승
    em.createQuery("update Product p set p.price = p.price * 1.1")
                        .executeUpdate();

    // (3) 출력 결과 : 1000
    System.out.println("Product 수정후 : " + productA.getPrice());
}
~~~
(1) 가격이 1000원인 상품A를 조회했다. 조회된 상품A는 영속성 컨텍스트에서 관리 된다.           
(2) 벌크 연산으로 모든 상품의 가격을 10% 상승시켰다. 따라서 상품A의 가격은 1100원이 되어야 한다.         
벌크 연산을 수행한 후에 상품 A의 가격을 출력하면 기대했던 1100원이 아니라 1000원이 출력된다.                 

벌크 연산 수행전 
- 상품 A를 조회했으므로 가격이 1000원인 상품 A가 영속성 컨텍스트에 괸리

벌크연산 수행 후 
- 벌크 연산은 영속성 컨텍스트를 통하지 않고 데이터베이스에 직접 쿼리한다.
- 따라서 영속성 컨텍스트에 있는 상품A와 데이터베이스에 있는 상품A의 가격이 다를 수 있다.
- DB에만 접근해서 데이터를 바꾸지만, 영속성 컨텍스트가 관리하고 있는 데이터도 건드려서 수정하지 않는다.



벌크성 쿼리를 실행하고 나서 영속성 컨텍스트를 초기화하고 싶으면 @Modifying(clearAutomatically = true) 옵션을 true로 지정하면 된다.
저런 부분을 방지하기 위해 스프링 데이터 JPA에서 제공 하는 기능이다.



