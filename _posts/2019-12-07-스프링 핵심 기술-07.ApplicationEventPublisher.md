---
title: 스프링 핵심 기술-07.ApplicationEventPublisher
date: 2019-12-07
categories:
- Spring
tags:
- Spring 
- ApplicationEventPublisher
- Event
comments : true
---

## IoC 컨테이너 8부 : ApplicationEventPublisher
### ApplicationEventPublisher?         
이벤트 프로그래밍에 필요한 인터페이스를 제공하기 때문에,           
이벤트 기반의 프로그래밍을 할 때 유용한 인터페이스이며, 옵저버 패턴 구현체입니다.      

#### 옵저버 패턴?
>옵서버 패턴(observer pattern)은 객체의 상태 변화를 관찰하는 관찰자들,       
즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴이다.

마찬가지로        
ApplicationEventPublisher도 마찬가지로 ApplicationContext가 상속받습니다.      
(ApplicationContext extends ApplicationEventPublisher)      


### 이벤트 만들기

#### (스프링 4.2 이전)
이벤트로 만들기 위해서는 ApplicationEvent를 상속받아야 했습니다.           
하지만 스프링 4.2부터는 상속받지 않더라도 이벤트로 사용이 가능해졌고, 뒤에 이후 버전 코드도 같이 있습니다.  

이벤트 클래스    
``` java 
// ApplicationEvent 이벤트로 만들기 , 스프링 4.2부터는 상속받지 않아도 이벤트로 사용 가능
public class MyEvent extends ApplicationEvent {

    private int data;

    // 이벤트를 발생시킨 소스를 전달 가능
    public MyEvent(Object source) {
        super(source);
    }

    // 만약 원하는 데이터가 있다면, 데이터도 같이 실어서 전달 가능
    public MyEvent(Object source, int data) {
        super(source);
        this.data = data;
    }

    public int getData() {
        return data;
    }
}
```

이벤트 핸들러 클래스      
``` java 
@Component
// 마찬가지로 스프링 4.2부터는 ApplicationListener 구현하지 않아도 된다.
public class MyEventHandler implements ApplicationListener<MyEvent> {

    @Override
    public void onApplicationEvent(MyEvent event){
        System.out.println("이벤트 받았다. 데이터는 " + event.getData());
    }
}
```


#### (4.2버전 이후)
이벤트 핸들러 클래스
``` java 
@Component
public class MyEventHandler {

    @EventListener // 상속 대신에 어노테이션 기반
    public void handle(MyEvent event){
        System.out.println("이벤트 받았다. 데이터는 " + event.getData());
    }
}
``` 

이벤트 클래스
``` java 
public class MyEvent{

    private int data;

    // 이벤트를 발생시킨 소스를 가지고 싶다면.
    private Object source;

    // 만약 원하는 데이터가 있다면, 데이터도 같이 실어서 전달 가능
    public MyEvent(Object source, int data) {
        this.source = source;
        this.data = data;
    }

    public Object getSource() {
        return source;
    }

    public int getData() {
        return data;
    }
}
```
바뀐 이벤트 클래스를 보면
이게 바로 스프링이 지향하는 철학입니다.

비침투성
지금 이 코드에는 스프링 패키지가 전혀 들어가 있지 않다.
스프링 프레임웍이 추구
비침투성, 논 인베, 포조 등 다 ㄱ똑같은 말인데,
내 코드에 스프링 코드 (프레임웍 코드가 노출되지 않는 것
포조 기반의 프로그래밍
이게 더 테스트가 편하고
유지보수하기도 도 편해집니다.


가급적 이런 방법으로 이벤트 기반의 코딩을 하길 추천한다.

1.어떤 스프링 코드도 없는 이벤트 클래스
2.어노테이션만 있는 이벤트 핸들러 클래스



### 이벤트 발생시키는 방법
ApplicationEventPublisher.publishEvent(ApplicationEvent event)를 사용합니다.
``` java 
@Component
public class AppRunner implements ApplicationRunner {

    // @Autowired
    // ApplicationContext applicationContext
    // 애도 상속 받았기 때문에 가능은 하다
    
    @Autowired
    ApplicationEventPublisher publisherEvent;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        publisherEvent.publishEvent(new MyEvent(this, 100));
    }
}
```
```
이벤트 받았다. 데이터는 100
```
정상적으로 출력이 되는 걸 확인할 수 있다.


### 이벤트 처리하는 방법

#### 동시에 두개의 핸들러가 동작한다면?

MyEventHandler
``` java 
@Component
public class MyEventHandler {

    @EventListener // 상속 대신에 어노테이션 기반
    public void handle(MyEvent event){
        System.out.println(Thread.currentThread().toString());
        System.out.println("MyEventHandler 이벤트 받았다. 데이터는 " + event.getData());
    }
}
```
AnotherHandler
``` java 
@Component
public class AnotherHandler {

    @EventListener
    public void handler(MyEvent myEvent){
        System.out.println(Thread.currentThread().toString());
        System.out.println("AnotherHandler " + myEvent.getData());
    }
}
``` 
``` 
Thread[main,5,main]
AnotherHandler 100
Thread[main,5,main]
MyEventHandler 이벤트 받았다. 데이터는 100
``` 
순서를 보장하지 않는다.      
(기본적으로는 synchronized)      


만약 순서를 정하고 싶다면 @EventListener 밑에
@Order 와 함께 사용.
``` java 
@EventListener
@Order(Ordered.HIGHEST_PRECEDENCE+2) // 가장 높은 순서를 주면 마지막에 실행이 된다. +1 아런 식으로 숫자를 더하는 것도 가능, - 불가
public void handler(MyEvent myEvent){
    System.out.println(Thread.currentThread().toString());
    System.out.println("AnotherHandler " + myEvent.getData());
}
```

혹은 비동기적으로 실행하고 싶다면 @Async와 함께 사용.
``` java 
@SpringBootApplication
@EnableAsync // 비동기적 실행
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
``` 
``` java 
@EventListener
@Async // 비동기적 실행
public void handler(MyEvent myEvent){
    System.out.println(Thread.currentThread().toString());
    System.out.println("AnotherHandler " + myEvent.getData());
}
``` 
``` 
Thread[task-1,5,main]
AnotherHandler 100
```
main이 아닌 다른 스레드가 사용된 것이 확인 가능합니다.      
다른 이벤트리스너도 비동기적 실행한다면, 리스너별 다른 스레드로 동작합니다.            
(물론 관련 설정들이 더 있지만, 그 부분에 대해 공부하는게 아니기 때문에 관련 내용은 지금은 생략하고 넘어감)       


이 외에도 스프링이 제공하는 기본 이벤트들이 있다.     
-ContextRefreshedEvent: ApplicationContext를 초기화 했더나 리프래시 했을 때 발생.    
-ContextStartedEvent: ApplicationContext를 start()하여 라이프사이클 빈들이 시작 신호를 받은 시점에 발생.     
-ContextStoppedEvent: ApplicationContext를 stop()하여 라이프사이클 빈들이 정지 신호를 받은 시점에 발생.     
-ContextClosedEvent: ApplicationContext를 close()하여 싱글톤 빈 소멸되는 시점에 발생.     
-RequestHandledEvent: HTTP 요청을 처리했을 때 발생.     

``` java 
@Component
public class MyEventHandler {

    @EventListener
    @Async
    public void handle(MyEvent event){
        System.out.println(Thread.currentThread().toString());
        System.out.println("MyEventHandler 이벤트 받았다. 데이터는 " + event.getData());
    }

    @EventListener
    @Async
    public void handle(ContextRefreshedEvent event){
        System.out.println(Thread.currentThread().toString());
        System.out.println("ContextRefreshedEvent");
    }

    @EventListener
    @Async
    public void handle(ContextClosedEvent event){
        System.out.println(Thread.currentThread().toString());
        System.out.println("ContextClosedEvent");
    }
}
``` 
```
2019-12-07 20:41:17.588  INFO 13457 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2019-12-07 20:41:17.588  INFO 13457 --- [           main] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 831 ms
2019-12-07 20:41:17.770  INFO 13457 --- [           main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService 'applicationTaskExecutor'
Thread[task-1,5,main]
ContextRefreshedEvent
2019-12-07 20:41:17.960  INFO 13457 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2019-12-07 20:41:17.963  INFO 13457 --- [           main] c.e.ioccontainer5.demo.DemoApplication   : Started DemoApplication in 1.536 seconds (JVM running for 2.01)
Thread[task-3,5,main]
MyEventHandler 이벤트 받았다. 데이터는 100
Thread[task-4,5,main]

// 종료 시에 
ContextClosedEvent
2019-12-07 20:42:07.366  INFO 13457 --- [extShutdownHook] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService 'applicationTaskExecutor'
```




