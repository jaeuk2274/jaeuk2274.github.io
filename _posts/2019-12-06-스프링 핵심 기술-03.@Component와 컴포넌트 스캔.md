---
title: 스프링 핵심 기술-03.@Component와 컴포넌트 스캔
date: 2019-12-06
categories:
- Spring
tags:
- Spring 
- IoC
- Component
- ComponentScan
- Functional Bean Definition
comments : true
---

## IoC 컨테이너 4부 : @Component와 컴포넌트 스캔
ㅋ
스프링 3.1부터 도입

가장 중요한 설정 베이스 패키지

문자열이 타입세이프하지 않아서
베이스 패키지 클래시스 메서드


기본값은
컴포넌트 스캔 붙이고 있는 그 클래스부터 컴포넌트 스캔을 시작한다

이 애플리케이션 클래스가 시작지점
- 부트 어플리케이션

이 클래스부터 타고들어 패키지 부터 타고들어가서 이 해당 패키지는 모두 탐색

만약 다른 패키지를 만든다면 스캔이 안됨ㅡㄷ

me.whiteship.jaeuk 에서 시작하면
me.whiteship.out 탐색 안됨

코드에서는 쓸 수 있으나 스캔이 되지 않는다
그래서 빈으로 등록이 안되고 오토와이어드가 안된다.ㅋㅁ


컴포넌트 스캔에서 중요한 건

public @interface ComponentScan {
    @AliasFor("basePackages")
    String[] value() default {};

    @AliasFor("value")
    String[] basePackages() default {};

    Class<?>[] basePackageClasses() default {};

두가지 필터 
걸러낸다
컴포넌트 스캔을 가지고 있는 어노테이션이 시작지점
@SpringBootApplication 

이 어플리케이션 클래스와 담고있는 패키지 안애 있는 모든것, 패키지 이하의 모든 들어있는 것은 다 스캔이 된다. 모든것부터 부터 이 패키지 안에

하지만 이 패키지 밖의 것은 스캔이 안된다.


1. 어디서부터 어디까지 스캔할 것이냐

2. 스캔하는 중 설정으로 걸러낼 
수 있다 
수 있다 필터


@ComponentScan(
    excludeFilters = {
    @Filter(type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class}), 
    @Filter(type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class})})
public @interface SpringBootApplication {

 익스클루드 필터 걸러주는 옵션
 두가지 필터 걸러냄
 TypeExcludeFilter
 AutoConfigurationExcludeFilter
 
 
 
 
 초기에 
 기본적으로 컴포넌트 어노테이션을 가지고 있는 어노테이션들 다 탐색
 
단점은 싱글톤 스콥 빈들은 초기에 다 생성을 한다.
구동시 
구동시 모든 구동시 모든 빈들을 전부 생성한다.
구동 시간이 오래 걸릴수도 있다. 생성해야될 빈이 많으면

구동 타임 1회성의인거고

그다음부터는 다시 빈을 잡아먹는다거나 하는
성능을 잡아먹는게 없으니까


상관없다고 생각하지만


구동시간이 중요하다면ㅍ예민하신 분들이라면

다른 방법을 고려할 수 있는데
스프링 최신버전 5에서 들어온

펑셔널을 사용한 빈 등록 방법
이 방법은 리플렉션이나 프록시를 만드는 기법들
성능에 영향을 준다 이 두가지 방법은

하지만 펑셔널 빈 등록 방법은 그 두가지 기술을 사용하지 않기 때문에
성능상(구동시간)의 장점이 있다.


'''
package me.whiteeship.springapplicationcontext; // 현재 패키지 

@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
		// 기존 실행코드
		// SpringApplication.run(DemoApplication.class, args);

		// 자바 11부터 app 이라는 로컬 variable 변수 활용 가능
		// 하지만 난 11이 아니라.. 추후 적용도 고려하여 8에서 가능한 방식으로만 정리 예정입니다.
		// var app = new SpringApplication(DemoApplication.class);
		SpringApplication app = new SpringApplication(DemoApplication.class);

		app.addInitializers(new ApplicationContextInitializer<GenericApplicationContext>() {
			@Override
			public void initialize(GenericApplicationContext ctx) {
				ctx.registerBean(MyService.class); // 패키지 밖에 선언한 클래스
				ctx.registerBean(ApplicationRunner.class, new Supplier<ApplicationRunner>() {
					@Override
					public ApplicationRunner get() {
						return new ApplicationRunner() {
							@Override
							public void run(ApplicationArguments args) throws Exception {
								System.out.println("Functional Bean Definition");
							}
						};
					}
				});
			}
		});
		app.run(args);
    }
}
'''

그대로인데 람다식으로 줄인 코드
'''
@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
		SpringApplication app = new SpringApplication(DemoApplication.class);
		app.addInitializers((ApplicationContextInitializer<GenericApplicationContext>) ctx -> {
			ctx.registerBean(MyService.class); // 패키지 밖에 선언한 클래스, BookService 등 이 패키지에서 주입받는게 가능해짐.
			ctx.registerBean(ApplicationRunner.class, () -> args1 -> System.out.println("재욱 패키지 Functional Bean Definition"));
		});
		app.run(args);
    }
}
'''

정상적으로 구동되는 것을 볼 수 있다.
![readme](https://github.com/jaeuk2274/jaeuk2274.github.io/blob/master/_posts/img/%EC%8A%A4%ED%94%84%EB%A7%81%20%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC%20%ED%95%B5%EC%8B%AC%20%EA%B8%B0%EC%88%A0/03.Function%20bean%20definition.png?raw=true)



진짜 처음으로 왜 인텔리J 하는지 알아버렸네..      
회색으로 표시된 글씨 마우스 올리고 있으면, 자동 추천 변환이 뜨고 (람다식 변환)     
마우스 클릭 한번으로 바뀌고       
인텔리J 진짜 편하구나 새삼 느꼈네요... 대박..    

무튼 다시 돌아가서
이럴 때의 장점은 아까 말한대로

펑션을 사용한 빈 등록

1. 코딩을 좀 더 넣을 수 있다.
특정 조건에 따라 이런 빈을 등록한다던가ㄱ
ctx.registerBean(MyService.class); 
앞에 if 같은걸 넣어서 등


2.구동시 성능상의 장점
리플렉션 CG라이브러리 프록시 등 사용하지 않으니까.

3. 해당 패키지(컴포넌트 스캔이 시작되는 패키지)가 아닌 바깥의 패키지도 사용 가능


### 펑션을 활용한 빈 등록에 대한 생각
구동시의 성능상 더 장점이 있다고 해서 컴포넌트 스캔 방식을 버리고 이 방식으로 빈들을 전부 선언해주는 것은 아닌 것 같다.      
컴포넌트 스캔의 등장 배경에 반한다 -> 엄청난 설정 파일.. (모든 빈들..)      
그러나 직접 빈으로 등록하는 경우나
@Bean
public MyService myService(){
  return new MyService();
}
해당 패키지가 아닌 경로의 사용 등(MyService) 이런 식으로 등록하게 되는 빈들의 경우 사용하는 방법도 나쁘진 않다.     


### 컴포넌트 스캔의 동작 원리
컴포넌트 스캔은       
BeanFactoryPostProcessor를 구현한 ConfigurationClassPostProcessor와 연결되어 있다.      

BeanPostProcessor와 매우 비슷한데 실행 시점이 다르다.        

(컴포넌트 스캔으로 등록되는 빈들이 아닌) 다른 모든 빈들을 만들기 이전에 BeanFactoryPostProcessor의 구현체들을 적용을 해준다.       

= 직접 빈으로 등록하는 다른 빈들을 모두 등록하기 전에 컴포넌트 스캔을 해서 빈으로 등록을 해 준다.     
(ex. java @bean, xml, registerBean 등.. 컴포넌트 스캔X)      




### 정리
컴포넌트 스캔의 역할
가장 중요한 속성 2가지

컴포넌트 스캔의 대상들

펑션을 사용한 빈 등록


